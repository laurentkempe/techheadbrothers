<feed xmlns="http://www.w3.org/2005/Atom">
<title>Laurent Kemp√©</title>
<subtitle>One of the Tech Head Brothers</subtitle>
<link href="https://laurentkempe.com/atom.xml" rel="self"/>
<link href="https://laurentkempe.com"/>
<updated>2025-06-25T05:22:46.531Z</updated>
<id>https://laurentkempe.com/</id>
<author>
<name>Laurent Kemp√©</name>
</author>
<generator uri="https://astro.build/">Astro</generator>
  <entry>
    <title>SSE-Powered MCP Server with C# and .NET in 15.7MB executable</title>
    <link href="https://laurentkempe.com/2025/04/05/sse-powered-mcp-server-with-csharp-and-dotnet-in-157mb-executable/"/>
    <id>https://laurentkempe.com/2025/04/05/sse-powered-mcp-server-with-csharp-and-dotnet-in-157mb-executable/</id>
    <published>2025-04-05T10:35:19.000Z</published>
    <updated>2025-04-05T10:35:19.000Z</updated>
    <summary type="html">&lt;p&gt;Now that we&apos;ve explored how to leverage Model Context Protocol (MCP) servers to utilize external Tools and AI models in C# applications, how to write your own Standard Input/Output (STDIO) MCP server in C# using the modelcontextprotocol / csharp-sdk, and how we can dockerize your .NET C# MCP server to be able to distribute it for use by AI clients.
It&apos;s time to take a step further and explore how to leverage Server-Sent Events (SSE) MCP servers so that we can deploy them remotely, for example on a Raspberry Pi.&lt;/p&gt;
</summary>
    <category term="AI" scheme="https://laurentkempe.com/tags/ai" />
    <category term="ASP.NET Core" scheme="https://laurentkempe.com/tags/asp-dotnet-core" />
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
    <category term="LLM" scheme="https://laurentkempe.com/tags/llm" />
    <category term="SLM" scheme="https://laurentkempe.com/tags/slm" />
    <category term="MCP" scheme="https://laurentkempe.com/tags/mcp" />
  </entry>
  <entry>
    <title>Dockerizing your .NET C# MCP Server for AI Clients like Claude Desktop</title>
    <link href="https://laurentkempe.com/2025/03/27/dockerizing-your-dotnet-csharp-mcp-server-for-ai-clients-like-claude-desktop/"/>
    <id>https://laurentkempe.com/2025/03/27/dockerizing-your-dotnet-csharp-mcp-server-for-ai-clients-like-claude-desktop/</id>
    <published>2025-03-27T23:48:15.000Z</published>
    <updated>2025-03-27T23:48:15.000Z</updated>
    <summary type="html">&lt;p&gt;My previous post showed how easy it is to develop a .NET C# MCP server and write a client able to communicate with it. Now, the question is how we can distribute our MCP server to be used by AI clients. In this post, we&apos;ll leverage the knowledge acquired from my previous posts to explore how to dockerize your .NET C# MCP server.&lt;/p&gt;
</summary>
    <category term="AI" scheme="https://laurentkempe.com/tags/ai" />
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
    <category term="Docker" scheme="https://laurentkempe.com/tags/docker" />
    <category term="LLM" scheme="https://laurentkempe.com/tags/llm" />
    <category term="SLM" scheme="https://laurentkempe.com/tags/slm" />
    <category term="MCP" scheme="https://laurentkempe.com/tags/mcp" />
  </entry>
  <entry>
    <title>Model Context Protocol Made Easy: Building an MCP Server in C#</title>
    <link href="https://laurentkempe.com/2025/03/22/model-context-protocol-made-easy-building-an-mcp-server-in-csharp/"/>
    <id>https://laurentkempe.com/2025/03/22/model-context-protocol-made-easy-building-an-mcp-server-in-csharp/</id>
    <published>2025-03-22T10:08:37.000Z</published>
    <updated>2025-03-22T10:08:37.000Z</updated>
    <summary type="html">&lt;p&gt;In my previous post, I demonstrated how to use C# with &lt;code&gt;Microsoft.Extensions.AI&lt;/code&gt;, Ollama, and a nuget package called &lt;code&gt;mcpdotnet&lt;/code&gt; to interact with an existing MCP Server. Since then, &lt;code&gt;mcpdotnet&lt;/code&gt; has been elevated to become the &amp;quot;&lt;strong&gt;official C# SDK for Model Context Protocol servers and clients, maintained by Microsoft&lt;/strong&gt;&amp;quot;.&lt;/p&gt;
&lt;p&gt;The Model Context Protocol (MCP) is an open standard that enables seamless integration between AI systems and various data sources, allowing developers to create context-aware applications. In this post, we&apos;ll explore how to build a simple MCP server using C# and the &lt;strong&gt;modelcontextprotocol / csharp-sdk&lt;/strong&gt; library, which simplifies the process of creating and managing MCP servers.&lt;/p&gt;
</summary>
    <category term="AI" scheme="https://laurentkempe.com/tags/ai" />
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
    <category term="MCP" scheme="https://laurentkempe.com/tags/mcp" />
    <category term="SLM" scheme="https://laurentkempe.com/tags/slm" />
    <category term="LLM" scheme="https://laurentkempe.com/tags/llm" />
    <category term="Ollama" scheme="https://laurentkempe.com/tags/ollama" />
  </entry>
  <entry>
    <title>Harnessing AI in C# with Microsoft.Extensions.AI, Ollama, and MCP Server</title>
    <link href="https://laurentkempe.com/2025/03/15/harnessing-ai-in-csharp-with-microsoftextensionsai-ollama-and-mcp-server/"/>
    <id>https://laurentkempe.com/2025/03/15/harnessing-ai-in-csharp-with-microsoftextensionsai-ollama-and-mcp-server/</id>
    <published>2025-03-15T15:36:00.000Z</published>
    <updated>2025-03-15T15:36:00.000Z</updated>
    <summary type="html">&lt;p&gt;In the previous post &amp;quot;&lt;a href=&quot;https://laurentkempe.com/2025/01/27/leveraging-microsoftextensionsai-for-tool-calling-in-csharp/&quot;&gt;Leveraging Microsoft.Extensions.AI for Tool Calling in C#&lt;/a&gt;&amp;quot;, we explored how to create custom tools that enhance the capabilities of Large Language Models (LLMs). We demonstrated how integrating these technologies enables developers to build applications with advanced AI capabilities, facilitating more complex interactions.&lt;/p&gt;
&lt;p&gt;In this post, we&apos;ll take a step further and explore how to leverage &lt;strong&gt;Model Context Protocol (MCP)&lt;/strong&gt; servers to utilize external Tools and AI models in C# applications. We&apos;ll continue using Ollama to run local AI models.&lt;/p&gt;
</summary>
    <category term="AI" scheme="https://laurentkempe.com/tags/ai" />
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
    <category term="MCP" scheme="https://laurentkempe.com/tags/mcp" />
    <category term="SLM" scheme="https://laurentkempe.com/tags/slm" />
    <category term="Ollama" scheme="https://laurentkempe.com/tags/ollama" />
  </entry>
  <entry>
    <title>.NET Aspire and Dev Container</title>
    <link href="https://laurentkempe.com/2025/03/06/dotnet-aspire-and-dev-container/"/>
    <id>https://laurentkempe.com/2025/03/06/dotnet-aspire-and-dev-container/</id>
    <published>2025-03-06T22:59:39.000Z</published>
    <updated>2025-03-06T22:59:39.000Z</updated>
    <summary type="html">&lt;p&gt;.NET Aspire 9.1 was just released on February 25th, 2025. It comes with great new dashboard features, and there is more! One feature I am particularly interested in is the ability to use &lt;strong&gt;Dev Containers&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In this post, I will show you how to use the new .NET Aspire 9.1 with a Dev Container and JetBrains Rider. You could also use Visual Studio Code.&lt;/p&gt;
</summary>
    <category term=".NET Aspire" scheme="https://laurentkempe.com/tags/.net-aspire" />
    <category term="Dev Container" scheme="https://laurentkempe.com/tags/dev-container" />
    <category term="Docker" scheme="https://laurentkempe.com/tags/docker" />
    <category term="Rider" scheme="https://laurentkempe.com/tags/rider" />
  </entry>
  <entry>
    <title>Building Local AI Agents: Semantic Kernel Agent with Functions in C# using Ollama</title>
    <link href="https://laurentkempe.com/2025/03/02/building-local-ai-agents-semantic-kernel-agent-with-functions-in-csharp-using-ollama/"/>
    <id>https://laurentkempe.com/2025/03/02/building-local-ai-agents-semantic-kernel-agent-with-functions-in-csharp-using-ollama/</id>
    <published>2025-03-02T11:19:46.000Z</published>
    <updated>2025-03-02T11:19:46.000Z</updated>
    <summary type="html">&lt;p&gt;In my previous post, we saw how to &lt;a href=&quot;https://laurentkempe.com/2025/03/01/building-local-ai-agents-semantic-kernel-and-ollama-in-csharp/&quot;&gt;build the simplest Semantic Kernel local AI agent using Semantic Kernel and Ollama in C#&lt;/a&gt;. In this short post, we will see how simple it is to extend the capabilities of the Semantic Kernel local AI agent by adding function calling.&lt;/p&gt;
</summary>
    <category term="AI" scheme="https://laurentkempe.com/tags/ai" />
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
    <category term="LLM" scheme="https://laurentkempe.com/tags/llm" />
    <category term="Ollama" scheme="https://laurentkempe.com/tags/ollama" />
    <category term="SLM" scheme="https://laurentkempe.com/tags/slm" />
    <category term="Semantic Kernel" scheme="https://laurentkempe.com/tags/semantic-kernel" />
  </entry>
  <entry>
    <title>Building Local AI Agents: Semantic Kernel and Ollama in C#</title>
    <link href="https://laurentkempe.com/2025/03/01/building-local-ai-agents-semantic-kernel-and-ollama-in-csharp/"/>
    <id>https://laurentkempe.com/2025/03/01/building-local-ai-agents-semantic-kernel-and-ollama-in-csharp/</id>
    <published>2025-03-01T15:08:16.000Z</published>
    <updated>2025-03-01T15:08:16.000Z</updated>
    <summary type="html">&lt;p&gt;The recent release of Microsoft&apos;s Semantic Kernel Agents Framework RC1 provides an excellent opportunity to explore its capabilities with C#. In this post, we&apos;ll walk through creating a simple agent using this framework and running it locally with Ollama.&lt;/p&gt;
&lt;p&gt;Let&apos;s dive in!&lt;/p&gt;
</summary>
    <category term="AI" scheme="https://laurentkempe.com/tags/ai" />
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
    <category term="LLM" scheme="https://laurentkempe.com/tags/llm" />
    <category term="Ollama" scheme="https://laurentkempe.com/tags/ollama" />
    <category term="Semantic Kernel" scheme="https://laurentkempe.com/tags/semantic-kernel" />
    <category term="SLM" scheme="https://laurentkempe.com/tags/slm" />
  </entry>
  <entry>
    <title>Harnessing DeepSeek-R1 distilled model with .NET Aspire and Ollama locally</title>
    <link href="https://laurentkempe.com/2025/02/01/harnessing-deepseek-r1-with-dotnet-aspire-and-ollama-locally/"/>
    <id>https://laurentkempe.com/2025/02/01/harnessing-deepseek-r1-with-dotnet-aspire-and-ollama-locally/</id>
    <published>2025-02-01T12:30:53.000Z</published>
    <updated>2025-02-01T12:30:53.000Z</updated>
    <summary type="html">&lt;p&gt;In my earlier posts, I&apos;ve demonstrated how to install Ollama using the Windows installer. However, for developers, there&apos;s a more streamlined method to set up Ollama on your machine.&lt;/p&gt;
&lt;p&gt;In this blog post, we&apos;ll explore how to run DeepSeek-R1 by harnessing the capabilities of .NET Aspire alongside Ollama on your local environment.&lt;/p&gt;
</summary>
    <category term=".NET Aspire" scheme="https://laurentkempe.com/tags/.net-aspire" />
    <category term="AI" scheme="https://laurentkempe.com/tags/ai" />
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
    <category term="Ollama" scheme="https://laurentkempe.com/tags/ollama" />
    <category term="LLM" scheme="https://laurentkempe.com/tags/llm" />
    <category term="SLM" scheme="https://laurentkempe.com/tags/slm" />
  </entry>
  <entry>
    <title>Leveraging Microsoft.Extensions.AI for Tool Calling in C#</title>
    <link href="https://laurentkempe.com/2025/01/27/leveraging-microsoftextensionsai-for-tool-calling-in-csharp/"/>
    <id>https://laurentkempe.com/2025/01/27/leveraging-microsoftextensionsai-for-tool-calling-in-csharp/</id>
    <published>2025-01-27T13:32:02.000Z</published>
    <updated>2025-01-27T13:32:02.000Z</updated>
    <summary type="html">&lt;p&gt;In the previous post &amp;quot;&lt;a href=&quot;https://laurentkempe.com/2024/10/28/learning-ai-function-calling-in-csharp-with-llama-32-slm-and-ollama-running-on-your-machine/&quot;&gt;Learning AI function calling in C# with Llama 3.2 SLM and Ollama running on your machine&lt;/a&gt;&amp;quot;, we wrapped our head around the concept of tool calling and implemented a C# source generator enabling our functions to be called by Llama 3.2 SLM using Ollama.&lt;/p&gt;
&lt;p&gt;In this post, we will explore how to use Microsoft Extensions AI for tool calling in a simple .NET CLI application. We will leverage the power of Ollama and Llama 3.2 SLM to call functions and interact with the AI model using C#.&lt;/p&gt;
</summary>
    <category term="AI" scheme="https://laurentkempe.com/tags/ai" />
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
    <category term="LLM" scheme="https://laurentkempe.com/tags/llm" />
    <category term="Ollama" scheme="https://laurentkempe.com/tags/ollama" />
    <category term="SLM" scheme="https://laurentkempe.com/tags/slm" />
  </entry>
  <entry>
    <title>Learning AI function calling in C# with Llama 3.2 SLM and Ollama running on your machine</title>
    <link href="https://laurentkempe.com/2024/10/28/learning-ai-function-calling-in-csharp-with-llama-32-slm-and-ollama-running-on-your-machine/"/>
    <id>https://laurentkempe.com/2024/10/28/learning-ai-function-calling-in-csharp-with-llama-32-slm-and-ollama-running-on-your-machine/</id>
    <published>2024-10-28T17:22:35.000Z</published>
    <updated>2024-10-28T17:22:35.000Z</updated>
    <summary type="html">&lt;p&gt;I&apos;ve been trying to wrap my head around function/tool calling for a while now, and I&apos;m excited to share what I&apos;ve learned with you. It&apos;s a powerful way to let developers integrate advanced AI features directly into their applications. We&apos;ll walk through understanding the core concepts, setting up your environment, and implementing a practical example using a C# source generator.&lt;/p&gt;
</summary>
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
    <category term="AI" scheme="https://laurentkempe.com/tags/ai" />
    <category term="Ollama" scheme="https://laurentkempe.com/tags/ollama" />
    <category term="LLM" scheme="https://laurentkempe.com/tags/llm" />
    <category term="SLM" scheme="https://laurentkempe.com/tags/slm" />
  </entry>
  <entry>
    <title>Run Phi-3 SLM on your machine with C# Semantic Kernel and Ollama</title>
    <link href="https://laurentkempe.com/2024/05/01/run-phi-3-slm-on-your-machine-with-csharp-semantic-kernel-and-ollama/"/>
    <id>https://laurentkempe.com/2024/05/01/run-phi-3-slm-on-your-machine-with-csharp-semantic-kernel-and-ollama/</id>
    <published>2024-05-01T10:31:03.000Z</published>
    <updated>2024-05-01T10:31:03.000Z</updated>
    <summary type="html">&lt;p&gt;Microsoft recently unveiled Phi-3, the latest iteration of their Small Language Model (SLM). And hot on its heels is Ollama, a powerful tool that enables you to run SLMs and LLMs right on your own machine.&lt;/p&gt;
&lt;p&gt;Excited to dive in? In this guide, I&apos;ll show you how to harness the power of Phi-3 and Ollama using C# and Semantic Kernel. I&apos;ll walk you through the process of creating a simple console application to get you started on your SLM journey.&lt;/p&gt;
&lt;p&gt;So, let&apos;s get coding and unlock the potential of Phi-3 and Ollama on your machine!&lt;/p&gt;
</summary>
    <category term="Semantic Kernel" scheme="https://laurentkempe.com/tags/semantic-kernel" />
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
    <category term="Ollama" scheme="https://laurentkempe.com/tags/ollama" />
    <category term="LLM" scheme="https://laurentkempe.com/tags/llm" />
    <category term="SLM" scheme="https://laurentkempe.com/tags/slm" />
    <category term="AI" scheme="https://laurentkempe.com/tags/ai" />
  </entry>
  <entry>
    <title>What's new in C# 12</title>
    <link href="https://laurentkempe.com/2023/11/14/whats-new-in-csharp-12/"/>
    <id>https://laurentkempe.com/2023/11/14/whats-new-in-csharp-12/</id>
    <published>2023-11-14T17:00:00.000Z</published>
    <updated>2023-11-14T17:00:00.000Z</updated>
    <summary type="html">&lt;p&gt;C# 12 is the latest, just released, version of the popular programming language that runs on the .NET 8 platform. It introduces several new features that aim to improve the expressiveness, performance, and safety of the language. In this post, we will explore some of these features and see how they can benefit your code.&lt;/p&gt;
</summary>
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
  </entry>
  <entry>
    <title>Publish .NET Docker images using .NET SDK and GitHub Actions</title>
    <link href="https://laurentkempe.com/2023/10/30/publish-dotnet-docker-images-using-dotnet-sdk-and-github-actions/"/>
    <id>https://laurentkempe.com/2023/10/30/publish-dotnet-docker-images-using-dotnet-sdk-and-github-actions/</id>
    <published>2023-10-30T13:52:08.000Z</published>
    <updated>2023-10-30T13:52:08.000Z</updated>
    <summary type="html">&lt;p&gt;My previous blog posts talks about built-in container support in the .NET SDK. It allows you to create and publish Docker images for your .NET applications without writing any Dockerfile. I also showed how to use the Chiseled Ubuntu base images optimized for .NET and containers. We saw  how to publish your Docker images using the .NET SDK to GitHub Packages / Container Registry.&lt;/p&gt;
&lt;p&gt;Today, I want to show you how to publish your Docker images using the .NET SDK to GitHub Container Registry using GitHub Actions. It brings us to the next level of automation.&lt;/p&gt;
</summary>
    <category term=".NET SDK" scheme="https://laurentkempe.com/tags/dotnet-sdk" />
    <category term="Docker" scheme="https://laurentkempe.com/tags/docker" />
    <category term="GitHub" scheme="https://laurentkempe.com/tags/github" />
    <category term="GitHub Actions" scheme="https://laurentkempe.com/tags/github-actions" />
    <category term="GitHub Container Registry" scheme="https://laurentkempe.com/tags/github-container-registry" />
  </entry>
  <entry>
    <title>Simplify your .NET Docker image publishing workflow with the .NET SDK</title>
    <link href="https://laurentkempe.com/2023/10/24/simplify-your-dotnet-docker-image-publishing-workflow-with-the-dotnet-sdk/"/>
    <id>https://laurentkempe.com/2023/10/24/simplify-your-dotnet-docker-image-publishing-workflow-with-the-dotnet-sdk/</id>
    <published>2023-10-24T12:14:09.000Z</published>
    <updated>2023-10-24T12:14:09.000Z</updated>
    <summary type="html">&lt;p&gt;In my previous blog posts, I wrote about the &lt;strong&gt;built-in container support&lt;/strong&gt; in the &lt;strong&gt;.NET 7 SDK&lt;/strong&gt; that allows you to create and publish Docker images for your .NET applications without writing any Dockerfile. I also showed how to use the &lt;strong&gt;Chiseled Ubuntu&lt;/strong&gt; base images optimized for .NET and containers.&lt;/p&gt;
&lt;p&gt;For this blog post, I will explain how to publish your Docker images using the .NET SDK to &lt;strong&gt;GitHub Packages / Container Registry&lt;/strong&gt;. It is possible to publish to different &lt;strong&gt;container registries&lt;/strong&gt;, such as Docker Hub, GitHub, Azure Container Registry, or your own private registry. I will show you how to publish to GitHub Packages / Container Registry, but the process is similar for other registries.&lt;/p&gt;
&lt;p&gt;This blog post will help you learn how to leverage the .NET SDK&apos;s built-in container support to effortlessly distribute and run your .NET applications in the cloud using Docker. Stay tuned!&lt;/p&gt;
</summary>
    <category term=".NET SDK" scheme="https://laurentkempe.com/tags/dotnet-sdk" />
    <category term="Docker" scheme="https://laurentkempe.com/tags/docker" />
    <category term="GitHub" scheme="https://laurentkempe.com/tags/github" />
  </entry>
  <entry>
    <title>.NET 7 SDK built-in container improvements</title>
    <link href="https://laurentkempe.com/2023/03/13/dotnet-7-sdk-built-in-container-improvements/"/>
    <id>https://laurentkempe.com/2023/03/13/dotnet-7-sdk-built-in-container-improvements/</id>
    <published>2023-03-13T13:56:12.000Z</published>
    <updated>2023-03-13T13:56:12.000Z</updated>
    <summary type="html">&lt;p&gt;Are you looking for a fast and easy way to &lt;strong&gt;create and run .NET applications using Docker containers without writing any Dockerfile?&lt;/strong&gt; If so, you will be glad to know that Microsoft has introduced a new feature of the .NET SDK 7.0.200 that makes it possible to create and publish OCI container images directly from your project file. We have seen how &amp;quot;&lt;a href=&quot;https://laurentkempe.com/2022/11/14/dotnet-7-sdk-built-in-container-support-and-ubuntu-chiseled/&quot;&gt;.NET 7 SDK built-in container support and Ubuntu Chiseled&lt;/a&gt;&amp;quot; can be used together. It lets us &lt;strong&gt;create small and secure containers&lt;/strong&gt; for our .NET applications easily. We went from a first docker image of 216MB down to 48.3 MB. That is more than a &lt;strong&gt;77% reduction in size&lt;/strong&gt;. .NET SDK 7.0.200 bring some new capabilities. We will explore some in this post.&lt;/p&gt;
</summary>
    <category term=".NET SDK" scheme="https://laurentkempe.com/tags/dotnet-sdk" />
    <category term="Docker" scheme="https://laurentkempe.com/tags/docker" />
  </entry>
  <entry>
    <title>Debugging Dapr applications with Rider or Visual Studio: A better way</title>
    <link href="https://laurentkempe.com/2023/02/27/debugging-dapr-applications-with-rider-or-visual-studio-a-better-way/"/>
    <id>https://laurentkempe.com/2023/02/27/debugging-dapr-applications-with-rider-or-visual-studio-a-better-way/</id>
    <published>2023-02-27T13:07:46.000Z</published>
    <updated>2023-02-27T13:07:46.000Z</updated>
    <summary type="html">&lt;p&gt;Dapr is an impressive set of APIs for building distributed applications with any language and platform. It provides a set of building blocks that you can use to build microservices. Dapr is based on sidecar architecture. Meaning that you need to run a Dapr sidecar for each of your applications. &lt;strong&gt;How do you debug your Dapr apps effectively?&lt;/strong&gt; If you have been using PowerShell scripts to run and attach your debugger, you know how tedious and error-prone it can be. Ready to see how to use Rider or Visual Studio to debug your Dapr apps with ease and confidence?&lt;/p&gt;
</summary>
    <category term=".NET" scheme="https://laurentkempe.com/tags/dotnet" />
    <category term="Dapr" scheme="https://laurentkempe.com/tags/dapr" />
    <category term="Rider" scheme="https://laurentkempe.com/tags/rider" />
    <category term="Visual Studio" scheme="https://laurentkempe.com/tags/visual-studio" />
  </entry>
  <entry>
    <title>Refactoring huge C# code base in minutes</title>
    <link href="https://laurentkempe.com/2023/02/20/refactoring-huge-csharp-code-base-in-minutes/"/>
    <id>https://laurentkempe.com/2023/02/20/refactoring-huge-csharp-code-base-in-minutes/</id>
    <published>2023-02-20T13:38:00.000Z</published>
    <updated>2023-02-20T13:38:00.000Z</updated>
    <summary type="html">&lt;p&gt;With my team, we like to keep our C# code base updated. So, recently we went to .NET 7 and C# 11. At the same time, we were still adopting some of the new capabilities of .NET 6 and C# 10. Our code base is large, so it takes some time. One of the new features that we planned to use was the &lt;code&gt;ArgumentNullException.ThrowIfNull&lt;/code&gt; method, which throws an exception if an argument is null. In this post, I will show you how I effortlessly did that refactoring by letting the machine work and not the human üòÅ (me). In the past, I used the same approach to migrate lots of code that used &lt;code&gt;Assert.True()&lt;/code&gt; to &lt;code&gt;Assert.That(, Is.True)&lt;/code&gt; and for some other even more complex cases. We will use ReSharper and Rider for that.&lt;/p&gt;
</summary>
    <category term=".NET" scheme="https://laurentkempe.com/tags/dotnet" />
    <category term="C#" scheme="https://laurentkempe.com/tags/csharp" />
    <category term="ReSharper" scheme="https://laurentkempe.com/tags/resharper" />
    <category term="Rider" scheme="https://laurentkempe.com/tags/rider" />
  </entry>
  <entry>
    <title>.NET 7 SDK built-in container support and Ubuntu Chiseled</title>
    <link href="https://laurentkempe.com/2022/11/14/dotnet-7-sdk-built-in-container-support-and-ubuntu-chiseled/"/>
    <id>https://laurentkempe.com/2022/11/14/dotnet-7-sdk-built-in-container-support-and-ubuntu-chiseled/</id>
    <published>2022-11-14T13:40:41.000Z</published>
    <updated>2022-11-14T13:40:41.000Z</updated>
    <summary type="html">&lt;p&gt;End of summer 2022, the .NET team at Microsoft announced two things related to containers: .NET in Chiseled Ubuntu containers and then a week after built-in container support in the .NET 7 SDK. I have talked about both topics on two episodes of the French podcast &lt;a href=&quot;https://devdevdev.net/&quot;&gt;devdevdev.net&lt;/a&gt; by my friend &lt;a href=&quot;https://twitter.com/c2iClark&quot;&gt;Richard Clark&lt;/a&gt;. In this post, I will explain what those are and how to combine them.&lt;/p&gt;
</summary>
    <category term="ASP.NET Core" scheme="https://laurentkempe.com/tags/asp-dotnet-core" />
    <category term="Docker" scheme="https://laurentkempe.com/tags/docker" />
    <category term="Ubuntu" scheme="https://laurentkempe.com/tags/ubuntu" />
    <category term=".NET SDK" scheme="https://laurentkempe.com/tags/dotnet-sdk" />
  </entry>
  <entry>
    <title>Experimenting with .NET 7, WASM, and WASI on Docker</title>
    <link href="https://laurentkempe.com/2022/10/31/experimenting-with-dotnet-7-wasm-and-wasi-on-docker/"/>
    <id>https://laurentkempe.com/2022/10/31/experimenting-with-dotnet-7-wasm-and-wasi-on-docker/</id>
    <published>2022-10-31T13:25:10.000Z</published>
    <updated>2022-10-31T13:25:10.000Z</updated>
    <summary type="html">&lt;p&gt;On October 24th, Docker announced the support of WASM and WASI in a new technical preview release. I wanted to try it out and see how it works with .NET 7. If you want to know more about WASM and WASI you can read the introduction from my previous post, &amp;quot;&lt;a href=&quot;https://laurentkempe.com/2022/10/29/using-wasm-and-wasi-to-run-dotnet-7-on-a-raspberry-pi-zero-2-w/&quot;&gt;Using WASM and WASI to run .NET 7 on a Raspberry PI Zero 2 W&lt;/a&gt;&amp;quot;.&lt;/p&gt;
</summary>
    <category term="WASM" scheme="https://laurentkempe.com/tags/wasm" />
    <category term="WASI" scheme="https://laurentkempe.com/tags/wasi" />
    <category term="Docker" scheme="https://laurentkempe.com/tags/docker" />
    <category term=".NET" scheme="https://laurentkempe.com/tags/dotnet" />
  </entry>
  <entry>
    <title>Using WASM and WASI to run .NET 7 on a Raspberry PI Zero 2 W</title>
    <link href="https://laurentkempe.com/2022/10/29/using-wasm-and-wasi-to-run-dotnet-7-on-a-raspberry-pi-zero-2-w/"/>
    <id>https://laurentkempe.com/2022/10/29/using-wasm-and-wasi-to-run-dotnet-7-on-a-raspberry-pi-zero-2-w/</id>
    <published>2022-10-29T11:04:42.000Z</published>
    <updated>2022-10-29T11:04:42.000Z</updated>
    <summary type="html">&lt;p&gt;WebAssembly (WASM) and WebAssembly System Interface (WASI) are opening new opportunities for developers. .NET developers became familiar with WASM when Blazor WebAssembly was released. Blazor WebAssembly runs client-side in the browser on a WebAssembly-based .NET runtime. WASI is bringing WASM out of the browser world by providing a system interface to run WebAssembly outside the web. It is a standard for how WASM modules interact with the host environment. This post will show you how to run .NET 7 on a Raspberry PI Zero 2 W using WASM and WASI.&lt;/p&gt;
</summary>
    <category term="WASM" scheme="https://laurentkempe.com/tags/wasm" />
    <category term="WASI" scheme="https://laurentkempe.com/tags/wasi" />
    <category term="ASP.NET Core" scheme="https://laurentkempe.com/tags/asp-dotnet-core" />
    <category term="Raspberry Pi" scheme="https://laurentkempe.com/tags/raspberry-pi" />
  </entry></feed>